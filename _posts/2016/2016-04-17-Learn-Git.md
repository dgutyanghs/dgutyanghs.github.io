---
title: Git 学习随想
tags: [编程,日志]
---

使用 Git 有几年时间了, 如果是其他的编程技术, 可能自己早就系统的学习了, 但是对于 Git 莫名的有一种恐慌. 尤其是当自己的提交和别人的发生冲突的时候, 总是想着赶快把这个问题解决了. 对 Git 的使用也就保留在可以把代码提交到服务器, 会克隆别人的仓库. 一年前的时候, 从一个同事那里有学会了如何打包. 更多的东西, 就不会了. 而且很多命令觉得怪怪的, 最基本的会使用外, 其他的更多的东西, 就不知道怎么做了. 有那么几次, 我看到 Git 官方教程, 但是看到其中的数据库什么的, 就觉得这些东西太底层了, 我只是 Git 的使用者, 我不用去了解这些东西, 所以自己就一直停留在原来的,对 Git 使用的最初级的阶段. 直到上周, 我从网上下载了 [Pro Git] 并静下心来读了那么一小段, 然后我觉得, 这个书才是我应该读的 Git 的教程. 之前我还读过一个中文的教程, 其实更准确的说, 是别人对 Git 使用的总结, 最常用的命令肯定是讲了的, 但是为什么会这样, 当遇到问题的时候, 又该如何解决, 这些问题, 哪本书中并没有细讲.

[Pro Git] 这本书是 [GitHub] 的两位位员工--- Scott Chacon 和 Ben Straub ---写的 Git 的教程. 内容非常的详实. 如果你打算学习 Git 那么读这本书就对了. 它包含了 Git 操作的方方面面. 很多时候, 自己在学习的道路上走的弯路, 往往是因为自己选学习的教程不好而引发的. 还有一些, 是因为自己不愿意花时间去系统的学习造成的. 不想系统的学习, 而只是边学边用, 甚至是只用不学, 以期节省时间, 最后会发现, 这样做, 自己根本记不住一些非常常见的操作, 因为自己脑子里, 没有这个东西的系统知识, 有的只是零散的知识, 而零散的知识其实是最容易被遗忘的. 同时, 因为自己没有投入时间去学习, 在使用的时候, 自己更不会投入时间去记忆那些自己工作中已经用到了的命令, 当自己工作中的问题解决了, 对解决这些问题用到的知识, 如果你没有系统学习的念头, 又怎么可能会有记忆这个解决方案的动机呢? 所以, 边用边学, 如果你用的不是非常的频繁的话, 基本上就是, 你每用一次都要重学一次. 好在现在网络发达了, 搜索引擎足够强大, 可以随时检索信息. 但是可以想象, 因为不愿意在系统学习上下功夫, 而边用边学最后浪费的时间一定比系统的学习涉及到的知识点用的时间要多. 边用边学, 这个工具永远都是你的拦路虎,你永远也只是这个工具的普通使用者. 系统的学习之后, 基本上就就会变成一个工具的高级用户, 甚至是专家用户. 不但可以更轻松的使用这个工具, 而且可以创造性的使用, 可以变着花的使用.

在使用 Git 中, 另外有一些东西也让我觉得自己感慨. 其实软件已经给出了足够多的提示了, 只是因为自己的英语能力太弱, 所以直接忽略了软件给出的提示, 因此就造成在遇到问题的时候, 不是按照 Git 提示的方法来解决, 而是通过搜索引擎. 相比于其他的软件,Git 中有更多更偏僻的单词, 包括它的命令,概念都是这样. 所以很多时候, 对于英语能力不强的人来说, 这就形成了一个巨大的障碍. 其实其实英语本不该是一个障碍, 尤其是对于一个软件中的英语. 一个软件中的英语单词的个数比较是有限的, 如果自己有专研的精神, 为什么对于那么几个让自己拿不准的单词不查一下呢? 其实, 语言的障碍不在与自己的语言水平, 而是自己是否对语言有抵触. 如果你没有抵触的心理, 那么仔细的阅读, 你会发现, 软件中的英语提示大部分的单词自己是认得的, 软件提示的大致意思自己的明白的. 但是对于一门不是自己母语的语言, 我想大约人们先天都是有抵触情绪存在的. 不然就难以解释为什么, 我早就注意到对语言障碍的问题, 在使用 Git 的时候, 却还是会不自觉的因为语言抵触而不能很好的使用 Git.

以上是在学习 Git 之后引发的一些感想了, 其实和学习 Git 没有什么特别紧密的联系, 任何一个新的知识, 都是应该尽快的系统学习的; 而不论什么时候, 遇到英语, 自己应该有信心来克服语言障碍, 而不是因为语言障碍的存在就它让自己成立自己进步的拦路虎.

这次系统的学习 Git, 让我掌握 Git 软件中各种命令存在的原因, 明白了为什么要用分支(branch), 如何用分支, 怎么合并(merge), 如何什么有时候合并会很顺利, 有时候却会有冲突. 原来对于什么每个 git 仓库都有一个 master 分支感到困惑, 还有什么 origin , HEAD 等等. 虽然这些单词的意义都知道, 但是它们的特殊意义是什么, 没有去细想过, 现在知道了. master 是每次克隆仓库的时候, git 默认为你创建的分支名, 没有什么特殊的含义, 就是一个仓库名而已. 不过习惯上, 大家使用这个仓库保存软件的稳定版本. origin 指的则是克隆仓库时远程仓库 URL 的别名, 使用别名是为了方便, 不用每次都输入常常的一串文字. 而 HEAD 是你当前工作的分支的最后的一次提交.

最后说一个命令, 在工作中用到的命令. 我们知道在 Windows 上文件名是不区分大小写的, 因此如果你有一个文件名字叫做 reademe.md 现在你改成 ReadMe.md 这个Windows 操作系统会认为你没有改动的. Linux , Unix 以及苹果的 xOS 是区分大小写的, 很多编程语言也是区分大小写的. 我遇到的问题是这样的, 我用的是 Nodejs 最初的时候我有一个文件叫做 xxx.js 后来改成了大写 XXX.js. 但是因为 xxx.js 已经加入到仓库中去了所以 git 不认为我重命名了这个文件.  **对文件名大小写是否敏感,Nodejs 依赖操作系统, 而 Git 依赖系统给出的文件状态**. 这样当我从 Windows 上 使用 `git achive` 打包文件, 放到 Linux 下运行的时候, 发现 Nodejs 找不到 XXX.js . 通过 `ls` 命令查看, 果然目录下只有 xxx.js 的文件. 于是我疑惑了, 我明明已经改动了文件名了啊, 这么打包之后的又改了回来呢? 通过 `git status`, 我看到在仓库中根本就没有 XXX.js 只有 xxx.js 的改动. 于是我明白仓库中根本没有觉察到我重命名了文件. 那怎么办呢? 这个时候我想到了 git 自身的重命名命令, 使用 `git mv` 命令之后 Git 系统知道这个文件被重命名了, 提交之后重新打包果然就可以了. 所以`git mv`如果是在 Windows 上使用的话, 和直接使用 `mv` 效果是不一样的. 我想这个问题,注意到的人可能不多.不能算是程序的 Bug 但是这种小的坑, 应该有人提醒才对, 但是无论是 Nodejs 还是 Git 都很少有人提到这样的问题. 可能开发人员用 Windows 的太少了吧.


[Pro Git]: https://www.git-scm.com/book/zh/v2 "Pro Git 中文版"
[GitHub]: https://github.com
