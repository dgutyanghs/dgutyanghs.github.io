* 第一版前言
计算机语言是

#+BEIGN_QUOTE
一种表达有关方法学思想的新颖的形式化媒介.
#+END_QUOTE
#+BEGIN_QUOTE
"计算机科学" 并不是一种科学, 而且其重要性也与计算机本身并无太大关系. 计算机革命是有关我们如何去思考的方法, 以及我们如何去表达自己的思考的一个革命.
#+END_QUOTE
计算机革命是 *思考方法* 的革命, 是 *表达思考* 的革命.
#+BEGIN_QUOTE
数学为精确的处理 "是什么" 提供了一种框架, 而计算则为精确的处理 "怎么做" 的概念提供了一种框架.
#+END_QUOTE

* 第一章 构造过程抽象

#+BEGIN_QUOTE
计算过程是存在于计算机里的一类抽象事物, 在其演化进程中, 这些过程会操作一些被称为 *数据* 的抽象事务.
#+END_QUOTE

****** 用 Lisp 编程
#+BEGIN_QUOTE
我们将要用 Lisp 表述过程性的思想.
Our procedural thoughts will be expressed in Lisp.
#+END_QUOTE
使用 Lisp 的原因是, 它是研究一下三种内容的优秀的媒介:
1. 程序构造
2. 数据结构
3. 语言的特征如何与程序构造, 以及数据结构相关联

** 程序设计的基本元素

#+BEGIN_QUOTE
一个强有力的程序设计语言, 不仅是一种指挥计算机执行任务的方法. 它还应该成为一种框架, 使我们能够在其中组织自己有关计算过程的思想.
A powerfull programming language is more than just a means for instructing a computer to perform tasks. The language also servers as framework within which we organize our ideas about processes.
#+END_QUOTE

为了把简单的认识组合成复杂的认识, 每种功能强大的语言都提供了一下三种机制:
+ *基本表达式*, 用于表示语言所关心的最简单的个体(包括基本的数据和基本的过程)
+ *组合的方法*, 通过它们可以从简单的东西出发构造出符合的元素
+ *抽象的方法*, 通过它们可以为复合的对象命名, 并将复合对象当作单元去操作

*** 表达式
给 Lisp 一个表达式, Lisp 会把这个表达式的取值结果打印出来.
一个表达式, 就是有返回结果的东西.
在 Lisp 中, 可以所一切都是表达式:
1. 原子是表达式 a
2. 如果 a, b 都是表达式的话, ~(a . b)~ 也是表达式

复合表达式就是 Lisp 中组合的方法.

*** 命名和环境
#+BEGIN_QUOTE
程序设计语言中一个不可少的方面, 就是它需要提供一种通过名字去使用计算对象的方式.
#+END_QUOTE

Lisp 中, 通过 define 来为完成命名的工作.
#+BEGIN_scheme
(define pi 3.1415926)
#+END_scheme
命名使得编程语言有了抽象的能力.

*define 是一个特殊形式*.

Lisp 中常规形式是, 表的第一个元素是操作符, 其后其他元素是操作数. 表的计算值, 是把操作符作用到操作数上得到的结果.

而特殊形式就是不按常规的形式计算的其他的表示式.

#+BEGIN_QUOTE
我们可以将值与符号关联, 而后又能取出这些值, 这意味着解释器必须维护某种存储能力, 以便保持有关的 名字-值 对偶的轨迹. 这种存储被称为 *环境*.
#+END_QUOTE

*** 过程应用的替换模型
"完全展开而后规约" 的求值模型成为 *正则序求值*.

"先求值参数而后应用" 的方式, 称为 *应用序求值*.
*** 条件表达式和谓词
对于像这样的 =情况分析= 结构:
$$
\|x\|=\begin{cases}
x & if\space{} x > 0 \\
0 & if\space{} x = 0 \\
-x & if\space{} x<0
\end{cases}
$$
可以使用 cond 表示, *cond 是一个特殊形式*.
#+BEGIN_scheme
(define (abs x)
  (cond ((> x 0) x)
        ((= x 0) 0)
		((< x 0) (- x))))
#+END_scheme

/谓词/ 是说一个表达式, 它的值是被解释为正或假.




特殊形式表
| 关键值 | 示例                                  |
|--------+---------------------------------------|
| define | ~(define x a)~                        |
| cond   | ~(cond ((p1 e1) (p2 e2) ... (pn en))~ |
| if     | ~(if p consequent alter)~             |
| and    | ~(and e1 e2 ... en)~                  |
| or     | ~(or e1 e2 ... en)~                   |

