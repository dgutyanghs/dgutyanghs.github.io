Lambda 演算是使用 *变量绑定和替换*, 基于函 *数抽象和应用*, 来表达计算的数学逻辑中的形式系统. 由 Alonzo Church 在 1930 年首次引入.

* 描述
Lamdba 演算构成了 *lambda 术语* 语言. Lambda 术语语言通过定义一定的形式语法, 一个转化规则集合来定义. 而转换规则可以操作 lambda 术语. 这些转化规则可以被视为一个 *等价定律* 或 *操作定义*.
* Lambda 术语
一个合法的 Lambda 表达式, 就叫做 "lambda 术语".

下面的规则, 给出了合法的 lambda 术语一个递归定义:
1. 一个变量, ~x~, 是一个合法的 lambda 术语
2. 如果 ~t~ 是一个 lambda 术语, 而且 ~x~ 是一个变量, 那么 ~(\lambda{}x.t)~ 是一个 lambda 术语(叫做 lambda 抽象).
3. 如果 ~t~ 和 ~s~ 是 lambda 术语, 那么 ~(ts)~ 是一个 lambda 术语(叫做引用)

除此在没有其他东西是 lambda 术语了.

*lambda 抽象 \lambda{}x.t* 定义了一个匿名函数, 获取一个输入参数 ~x~, 并在表达式~t~ 中替换获取的 ~x~ . 这样就定义了一个匿名的, 输入 ~x~ 返回 ~t~ 的函数. 抽象绑定了术语 ~t~ 中的变量 ~x~. 例如 $\lambda{}x.x^2+2$ 就是函数 $f(x)=x^2+2$ 的 lambda 抽象.
*应用 ts* 表示应用一个函数t, 到一个输入 s 上, 也就是说, 这表达的是以输入 *s* 调用函数 *t*, 产生 */t(s)/*.

在 lambda 演算中没有变量申明的概念. 在诸如 $\lambda{}x.x+y$ 中, *y* 被 lambda 演算当作还没有定义的变量. $\lambda{}x.x+y$ 是语义合法的.
** 操作函数的函数
在 lambda 演算中, 函数是 "第一类值", 所以函数可以被用作输入, 可以被作为值返回.
** Alpha 等价
在 lambda 术语上定义的基本的等价形式就是 Alpha(\alpha{}) 等价. 它放映的是在 lambda 抽象中, 绑定变量的选择, (通常) 并不重要这个直觉. 例如 $\lambda{}x.x$ 和 $\lambda{}y.y$ 就是 alpha 等价的 lambda 术语. 但是术语 x 和 y 不是 alpha 等价的, 因为他们并没有在 lambda 抽象中绑定.
** 自由变量
1. x 中的自由变量就是x
2. $\lambda{}x.t$ 的自由变量的集合是 t 中的自由变量几何中去掉 x.
3. $ts$ 的自由变量集合是 t 和 s 自由变量集合的并集.
** Capture-avoidng 替换
假设 *t*, *s* 和 *r* 是lambda 术语, *x* 和 *y* 是变量. 记号 $t[x := r]$ 表示以避免捕获的方式用 *r* 替换 *t* 中的 *x*. 定义如下:
1. $x[x:=r] = r$
2. $y[x:=r] = y$ 如果 $x \ne y$
3. $(ts)[x:=r]=(t[x:=r])(s[x:=r])$
4. $(\lambda{}x.t)[x:=r] = \lambda{}x.t$
5. $(\lambda{}y.t)[x:=r] = \lambda{}y.(t[x:=r])$
   1. $x \ne y$
   2. $y\not\in r 自由变量集合$
   满足上面的条件, 对 r 来说 y 是新鲜的.
   
要保证替换不改变函数的意义, 新鲜条件(要求y *不* 在 r 的自由变量中) 是严格的.
结合 4, 5, 也就是说, r 中出现绑定的变量, 那么, 就不替换那些绑定的变量.

例如下面的替换就是不满足新鲜条件:

$(\lambda{}x.y)[y := x] = \lambda{}x.(y[y:=x])=\lambda{}x.x$

所以替换, 改变了函数的意义.
** Beta 消除
Beta 约化是说, 一个应用的形式 $(\lambda{}.t)s$ 可以约化为 $t[x:=s]$.
beta 约化对应为一个计算步骤. 这个计算步骤可以通过重复添加 beta 转化知道没有更多应用可以约化的时候停止.
* 形式定义
** 定义
Lambda 表达式由一下内容组成:
1. 变量 v_{1},v_{2},...,v_{n},...
2. 抽象符号 lambda '\lambda{}'和点'.'
3. 括号()

Lambda 表达式集合, A, 递归定义为:
1. 如果 x 是变量, 那么 x \in A
2. 如果 x 是变量, 且 M \in A, 那么 $(\lambda{}x.M) \in A$
3. 如果 M, N \in A, 那么 $(M N)\in A$
** 记号
为保持 lambda 表达式的简洁, 通常会使用下面的规范:
1. 最外层的括号去掉: M N 代替 (M N)
2. 应用被假设为左结合的: M N P 代替的是 ((M N) P)
3. 抽象体展开向右, 能有多远就多远: \lambda{}x.M N 意味着 \lambda{}x.(M N) 而不是 (\lambda{}x.M) N
4. 抽象的序列是压缩的: \lambda{}x.\lambda{}y.\lambda{}z.N 简写为 \lambda{}xyz.N
** 自由变量和绑定变量
抽象操作符, \lambda ,用来绑定出现在抽象体中的变量. 在一个抽象范围内的变量, 叫做被绑定的. 其他的变量是自由的.

表达式 M 的自由变量记为 FV(M). 定义如下:
1. FV(x)={x}, x是变量
2. FV(\lambda{}x.M)=FV(M)\{x}
3. FV(M N)= FV{M} U FV(N)

不包含自由变量的表达式被成为闭合的.
** 约化
lambda 表达式的意义通过这些表达式如何被约化来定义.
有三种约化:
1. \alpha{}-变化: 改变绑定的变量(\alpha)
2. \beta{}-约化: 应用函数到他的参数上(\beta)
3. \eta-变化: 使用捕获符号来展开(\eta)

两个表达式是\beta{}-等价的, 如果它们可以通过\beta{}-变化得到相同的表达式的话.
\alpha{}/\eta{} 等价的定义类似.

redex 是可约表达式. 约化一个可约表达式的表达式成为 reduct.
*** \alpha{}-变化
Alpha-变化, 又叫alpha-重命名, 允许绑定变量名改变.
**** 替换
替换, 写作 E[V:=R], 是用R替换所有的在E中出现的自由变量v.
定义如下:
1. x[x:=N] = N
2. y[x:=N] = y, 如果 x \ne y
3. (M_1 M_2)[x:=N] = (M_1[x:=N])(M_2[x:=N])
4. (\lambda{}x.M)[x:=N] = \lambda{}x.M
5. (\lambda{}y.M)[x:=N] =\lambda{}y.(M[x:=N]), 如果 x\ne y, 且 y $\not\in$ FV(N)

*** \beta-约化
Beta-约化是函数应用思想的反映. Beta-约化通过下面的术语替换来定义: $(\lambda{}V.E) E')$ 的 beta-约化是 E[V:E'].
*** \eta-变化
Eta-变化表达了可扩展性的思想, 两个函数是一样的, 当且仅当对所有的参数, 他们都给出一样的结果的时候. 当 x 不在 f 的自由变量集合中的时候, $\lambda{}x.(f x)$ 和 f 就服从 eta-变化. 
** 正规化
beta-约化的目的是为了计算一个值. 值在lambda 演算中是一个函数. 所以beta-约化会持续的进行, 知道表达式看起来向一个函数抽象.

一个不能被进一步约化(无论是 beta-约化规则, 或者是 eta-约化规则)的 lambda 表达式 , 那么这个表达式就是一个常规形式.
** 递归与固定点
递归函数, 一个函数, 调用自己. 对于lambda-演算来说, 因为不存在变量的声明, 所以, 就没法应用这个一个函数定义自身. 那么就只能使用 curring 方法, 把这个函数自身作为参数. 例如要计算 n!:

$$
n!=\begin{cases}
 1 &  n= 0 \newline
 n\times F(n-1) & n \ne 0
\end{cases}
$$
使用lambda演算来定义的话就是
$$
G:=\lambda{}r\lambda{}n.(1, if\space n=0; else\space n \times (r (n -1)))
$$
假设存满足下面的等式

r x = F x = G r x

那么就有
1. r= G r =: FIX G
2. FIX g := (r where r= g r) = g (FIX g)

满足条件1 的 r 成为 G的固定点. 满足 条件2 的 FIX 函数叫做固定操作符.

固定操作符 FIX 参数是一个函数, 返回值还是一个函数, 但是这个函数是一个递归的函数.

所以只要我们找到了 FIX 那么我们把 我们的 G 的定义作用用作 FIX 的参数, 这个返回的函数, 就可以用作计算了. 这个返回的函数会自动递归的.
** 标准术语
| 名字   | 定义                    |
|--------+-------------------------|
| I      | \lambda{}x.x            |
| K      | \lambda{}xy.x           |
| S      | \lambda{}xyz. x z (y z) |
| B      | \lambda{}xyz. x(y z)    |
| C      | \lambda{}xyz.x z y      |
| W      | \lambda{}xy.x y y       |
| U      | \lambda{}xy.y(x x y)    |
| \omiga | \lambda{}x.x x          |
| \Omiga | \omiga{}\omiga{}        |
| Y      | \lambda{}g.(\lambda{}x.g (x x)) (\lambda{}x.g (x x)) |
